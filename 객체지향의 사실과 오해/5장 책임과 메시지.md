# 5장 책임과 메시지

작성자: 수찬 이

지난 4장까지 저자의 말을 간략하게 요약하면, 객체지향 관점에서 가장 중요한 것은 객체의 **행동**이며, 행동을 유발하는 것은 다른 객체가 보낸 **메시지**와 메시지에 대해 응답할 **책임**이다. 

따라서 적절한 **책임**을 객체에게 할당하는 것이 설계에서 가장 중요한 것이라고 할 수 있다

<br>

### ✅추상적인 책임, 자율적인 책임

- 추상적이고 포괄적인 책임은 협력을 좀 더 다양한 환경에서 재사용할 수 있도록 유연성이라는 축복을 내려준다.
- 그러나 책임은 협력에 참여하는 의도를 명확하게 설명할 수 있는 수준 안에서 추상적이어야 한다.
- 자율적인 책임의 특징은 객체가 “어떻게 How” 해야 하는가가 아니라 “무엇 What”을 해야 하는가를 설명한다는 것이다.
    
    
    좋은 객체지향 설계를 위한 SOLID 원칙과 결합도를 생각해보면, 객체의 책임은 너무 커선 안되고, 객체간의 결합은 최대한 느슨해야한다고 한다.
    
     즉 객체들은 서로간에 구속을 최소화하여 스스로가 최대한 자유롭게 판단할수 있을때, 유연한 설계가 이루어지는 것이다.
    
    그렇다면 자유로운 객체가 되기 위해서는 할당된 책임이 자율적이여야 될 것이다.
    
    이를 보다 구체화해보면, 자율적인 책임은 추상적인 메시지를 통해 주어지게 될 것이다.
    
    만약 선생이란 객체가 학생이란 객체에게 학생이 오늘 공부한것을 알고 싶어서,
    
    > “오늘 1교시에 필기한 노트랑 2교시에 필기한노트, 3교시에 필기한노트, 4교시에 필기한노트를 가져와”
    > 
    
    라고 메시지를 보낸다면, 학생객체는 그 4가지 노트를 반환하는수밖에없다.
    
    즉 매개변수로 1교시공부량,2교시공부량,3교시공부량,4교시 공부량을 모두 입력받아 그만큼 구체적인 반환값을 요구한 메시지(메소드 호출)이며,
    
    학생 객체는 이에대해 딱 정해진 반환값만 반환할 수 있을것이다.
    
    애플리케이션에서 위와같은 설계를할 경우, 만약 기획자가 바뀌어 선생객체나 학생객체를 바꿀일이 생긴다면?
    
    바뀐 학생객체는 “공부를 5교시부터 열심히한다”던가하는 등 다른 특성이있다면?
    
    그럼 **메시지를 다시 수정**(메소드를 다시 수정)해야할일이 생기며 이는 유연성이 떨어지는 설계가 된다.
    
    하지만 만약 처음부터 메시지가
    
    > “오늘공부한거 가져와”
    > 
    
    라고 적당히 추상화되었다면, 선생과 학생이 아무리 바뀌어도 학생은 메시지의 책임에 스스로 행동을 결정할수 있게된다.
    
    이처럼 **적절히 추상화된 메시지**가 **적절한 책임**을 부여하기 위한 핵심이다.
    
<br>

### ✅메시지

- 객체가 다른 객체에게 접근할 수 있는 유일한 방법은 요청을 전송하는 것뿐이다.
- 그리고 이 요청을 우리는 메시지라고 부른다.
- 메시지는 객체로 하여금 자신의 책임, 즉 행동을 수행하게 만드는 유일한 방법이다.
- 객체가 수신할 수 있는 메시지의 모양이 객체가 수행할 책임의 모야을 결정한다.
- 메시지는 객체들이서로 협력하기 위해 사용할 수 있는 유일한 의사소통 수단이다.
- 객체가 메시지를 수신할 수 있다는 것은 객체가 메시지에 해당하는 책임을 수행할 수 있다는 것을 의미한다.
- 객체가 유일하게 이해할 수 있는 의사소통 수단은 메시지뿐이며 객체는 메시지를 처리하기 위한 방법을 자율적으로 선택할 수 있다.

<br>

### ✅메서드

- 메시지를 처리하기 위해 내부적으로 선택하는 방법을 메서드
- 어떤 객체에게 메시지를 전송하면 결과적으로 메시지에 대응하는 특정 메서드가 실행된다.
- 메시지를 수신한 객체가 실행 시간에 메서드를 선택할 수 있다는 사실은 다른 프로그래밍 언어와 객체지향 프로그래밍 언어를 구분 짓는 핵심적인 특징 중 하나다.
- 이것은 프로시저 호출에 대한 실행 코드를 컴파일 시간에 결정하는 절차적인 언어와 확연히 구분되는 특징이다.
- 외부에서 요청을 하는것을 메시지를 통해서 요청하고, 자율적인 객체 내부적으로는 메서드를 활용해서 해당 메시지를 처리한다.

<br>

### ✅다형성

- 서로 다른 타입에 속하는 객체들이 동일한 메시지를 수신할 경우 서로 다른 메서드를 이용해 메시지를 처리할 수 있는 매커니즘을 가리킨다.
- 다형성을 하나의 메시지와 하나 이상의 메서드 사이의 관계로 볼 수 있다.
- 서로 다른 객체들이 다형성을 만족시킨다는 것은 객체들이 동일한 책임을 공유한다는 것을 의미한다.
- 메시지 송신자의 관점에서 다형적인 수신자들을 구별할 필요가 없으며 자신의 요청을 수행할 책임을 지닌다는 점에서 모두 동일하다.
- 기본적으로 다형성은 동일한 역할을 수행할 수 있는 객체들 사이의 대체 가능성을 의미한다.
- 다형성은 송신자와 수신자 간의 객체 타입에 대한 결합도를 메시지에 대한 결합도를 낮춤으로써 달성된다.

<br>

### ✅객체 사상

- 객체 지향 애플리케이션의 중심 사상은 연쇄적으로 메시지를 전송하고 수신하는 객체들 사이의 협력 관계를 기반으로 사용자에게 유용한 기능을 제공하는 것이다.
- 클래스는 단지 동적인 객체들의 특성과 행위를 정적인 텍스트로 표현하기 위해 사용할 수 있는 추상화 도구일 뿐이다.

<br>

### ✅흔한 실수

- 객체 자체에 초점을 맞출 경우 가장 흔히 범하게 되는 실수는 협력이라는 문맥을 배제한 채 객체 내부의 데이터 구조를 먼저 생각한 후 데이터 조작에 필요한 오퍼레이션을 나중에 고려하는 것이다.
- 독립된 객체의 상태와 행위에 대해 고민하지 말고 시스템의 기능을 구현하기 위해 객체가 다른 객체에게 제공해야 하는 메시지에 대해 고민하라.
- 메시지가 객체를 선택하게 해야 한다. 메시지가 객체를 선택하게 만들려면 메시지를 중심으로 협력을 설계해야 한다.

<br>

### ✅인터페이스

- 인터페이스의 사용법을 익히기만 하면 내부 구조나 동작 방식을 몰라도 쉽게 대상을 조작하거나 의사를 전달할 수 있다.
- 인터페이스 자체는 변경하지 않고 단순히 내부 구성이나 작동 방식만을 변경하는 것은 인터페이스 사용자에게 어떤 영향도 미치지 않는다.
- 대상이 변경되더라도 동일한 인터페이스를 제공하기만 하면 아무런 문제 없이 상호작용할 수 있다.

추상화된 메시지를 수신할 수 있는 여러 개체들은 타입으로 추상화될 수 있고, 이를 보다 추상화시키면 **상위클래스** 또는 **인터페이스**라는 방식으로 구현될 수 있다.

즉 인터페이스를 정의하는 것은 메시지이며, 인터페이스는 수신할 수 있는 메시지 목록이라고 볼 수 있다.

> 특정 개체가 인터페이스를 구현했다면 이 개체는 해당 메시지들을 수신할수 있는 역할이라는 의미
> 

여기서 중요한 사실은 인터페이스라는 개념을 작은 단위에도 적용가능하단 점이다.

즉 현재 설계시점에서 해당 역할을 수행하는 객체가 하나만 존재할 지라도, **역할**이 존재하는 이상, 하나의 객체도 역할에 해당하는 인터페이스와 그 인터페이스의 구현으로 쪼개서 생각할 수 있다.

> Service interface 와 service impl 관계처럼 모든 역할은 메시지를 수신할 껍데기인 인터페이스와 메시지의 책임을 수행할 구현체로 분리가능하다! 이때 컨트롤러는 서비스 인터페이스를 바라보며, SOLID 원칙에서 의존의 역전 원칙(DIP)을 준수하게된다. 이를 구현체를 캡슐화한다고 표현하기도한다.
>
